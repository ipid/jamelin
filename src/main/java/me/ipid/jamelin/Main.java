/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package me.ipid.jamelin;

import com.google.common.base.Charsets;
import com.google.common.io.CharSource;
import com.google.common.io.Files;
import me.ipid.jamelin.compiler.JamelinErrorListener;
import me.ipid.jamelin.compiler.ProgramVisitor;
import me.ipid.jamelin.exception.JamelinRuntimeException;
import me.ipid.jamelin.thirdparty.antlr.PromelaAntlrLexer;
import me.ipid.jamelin.thirdparty.antlr.PromelaAntlrParser;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.ParseTree;

import java.io.File;
import java.io.IOException;

import static java.lang.System.out;

/**
 * 程序的主入口。
 */
public class Main {

    public static void main(String[] args) {
        if (args.length < 1) {
            out.println("[ERROR] 请输入文件路径。");
            System.exit(1);
        }

        new Main().run(args[0]);
    }

    /**
     * Main 类的主入口。
     *
     * @param filePath Promela 文件的路径
     */
    private void run(String filePath) {
        // 读入文件内容
        String content = readFile(filePath);

        // 生成解析树
        PromelaAntlrParser.SpecContext tree = getParseTree(content);

        // 打印解析树结构
        out.println("[INFO] 遍历解析树...");
        out.println(tree.getClass().getName());
        traverseParseTree(1, tree);

        // 使用 Visitor 生成状态图
        ProgramVisitor visitor = new ProgramVisitor();

        try {
            visitor.visit(tree);
        } catch (JamelinRuntimeException e) {
            System.out.printf("[ERROR] 语法错误：%s", e.getMessage());
        }
    }

    private String readFile(String filePath) {
        File file = new File(filePath);

        // 如果文件大小大于 16M
        if (file.length() > 16 * 1024 * 1024) {
            out.println("[ERROR] 文件过大。");
            System.exit(1);
        }

        // 将文件一次性读入 String 中
        CharSource charSource = Files.asCharSource(file, Charsets.UTF_8);
        String content = null;
        try {
            content = charSource.read();
        } catch (IOException ioe) {
            out.println("[ERROR] 读取文件时发生错误。");
            System.exit(1);
        }

        return content;
    }

    private void traverseParseTree(int k, ParserRuleContext tree) {
        StringBuilder spaceBuilder = new StringBuilder();
        for (int i = 0; i < k; i++) {
            spaceBuilder.append("    ");
        }
        String currLevelSpace = spaceBuilder.toString();

        // tree.children 可能是空
        if (tree.children == null) {
            return;
        }

        int index = 0;
        for (ParseTree child : tree.children) {
            index++;
            out.printf("%s%d. %s\n", currLevelSpace, index, child.getClass().getName());

            if (child instanceof ParserRuleContext) {
                ParserRuleContext context = (ParserRuleContext) child;
                traverseParseTree(k + 1, context);
            }
        }
    }

    private PromelaAntlrParser.SpecContext getParseTree(String content) {
        // 初始化 ANTLR 的一系列类
        CharStream stream = (CharStream) CharStreams.fromString(content);
        PromelaAntlrLexer lexer = new PromelaAntlrLexer(stream);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        PromelaAntlrParser parser = new PromelaAntlrParser(tokens);

        // 改变 ANTLR 的错误识别逻辑
        lexer.removeErrorListeners();
        parser.removeErrorListeners();

        JamelinErrorListener errorListener = new JamelinErrorListener();
        lexer.addErrorListener(errorListener);
        parser.addErrorListener(errorListener);

        // 生成解析树
        PromelaAntlrParser.SpecContext tree = parser.spec();
        if (errorListener.isErrorHappened()) {
            out.println("[ERROR] 语法错误。");
            System.exit(1);
        }

        return tree;
    }
}
